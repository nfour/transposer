// Generated by CoffeeScript 1.10.0
(function() {
  var Transposer, typeOf,
    hasProp = {}.hasOwnProperty;

  typeOf = require('lutils-typeof');

  module.exports = Transposer = (function() {
    function Transposer(data) {
      this.data = data != null ? data : {};
    }


    /*
    		Turns `data.key[1].c` into its represented data structure.
    		Sets the last key in the string to a value.
    
    		Returns null on an invalid dataKey.
    
    		@param	obj {Object}	'info[2].prop'
    		@param	value {Object}	'value!'
    		@return	{Object}		{ info: [ , , { prop: 'value!' } } ] } or null
     */

    Transposer.prototype.transpose = function(dataKey, value) {
      var i, index, item, j, key, last, len, len1, map, next, obj, parent, parts, ref, ref1, wrap;
      parts = dataKey.match(/([\w]+)|(\[["']?[^\[]+["']?\])/g);
      if (!parts.length > 1) {
        return (
          obj = {},
          obj["" + dataKey] = value,
          obj
        );
      }
      map = [];
      for (i = 0, len = parts.length; i < len; i++) {
        item = parts[i];
        if (key = (ref = item.match(/^\[([^\[]+)\]$/)) != null ? ref[1] : void 0) {
          if (/^\d+$/.test(key)) {
            parent = [];
            key = parseInt(key);
          } else {
            key = key.replace(/^['"]|['"]$/g, '');
            parent = {};
          }
        } else {
          key = item;
          parent = {};
        }
        map.push({
          key: key,
          parent: parent
        });
      }
      if (!map.length) {
        return null;
      }
      wrap = typeOf.Array(map[0].parent) ? [] : {};
      next = wrap;
      last = map[0];
      ref1 = map.slice(1);
      for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
        item = ref1[index];
        if (!(last.key in next)) {
          next[last.key] = item.parent;
        }
        next = next[last.key];
        last = item;
      }
      next[last.key] = value;
      return wrap;
    };


    /*
    		Transposes all properties of `object`, modifying `object`.
    		Any dataKey is deleted from the object in place of the transposed parent key.
    
    		@param obj {Object}	{ 'a.b': 1 }
    		@return obj			{ a: { b: 1 } }
     */

    Transposer.prototype.transposeAll = function(object) {
      var key, transposed, value;
      for (key in object) {
        value = object[key];
        if ((transposed = this.transpose(key, value)) !== null) {
          delete object[key];
          this.merge(object, transposed);
        }
      }
      return object;
    };


    /*
    		Sets a value in `this.data`.
    
    		@param transposed {String or Object} A dataKey or an object (such as that returned by .transpose())
    		@param value {mixed} A value to set that property, only used if `transposed` is a string
    		@return @data
     */

    Transposer.prototype.set = function(transposed, value) {
      if (typeOf.String(transposed)) {
        transposed = this.transpose(transposed, value);
      }
      return this.merge(this.data, transposed, null, true);
    };


    /*
    		Finds a value in `this.data`.
    
    		@param transposed {String or Object} A dataKey or an object (such as that returned by .transpose())
    		@return {mixed} undefined if not found, the value otherwise
     */

    Transposer.prototype.get = function(transposed) {
      var iterator;
      if (transposed == null) {
        return this.data;
      }
      if (typeOf.String(transposed)) {
        transposed = this.transpose(transposed);
      }
      iterator = function(pos1, pos2) {
        var key1, state1, state2, type, val1;
        state1 = (type = typeOf(pos1)) === 'object' || type === 'array';
        state2 = (type = typeOf(pos2)) === 'object' || type === 'array';
        if (state1 && state2) {
          for (key1 in pos1) {
            val1 = pos1[key1];
            break;
          }
          if (key1 in pos2) {
            return iterator(val1, pos2[key1]);
          }
        } else if (!state1) {
          return pos2;
        }
        return void 0;
      };
      return iterator(transposed, this.data);
    };


    /*
    		Merges obj2 into obj1, optionally overwriting properties.
    		Tries to always maintain an object's reference in obj1 unless `overwritten` is `true`.
    
    		@param obj1 {Object}		{ a: { c: 1 } }
    		@param obj2 {Object}		{ a: { d: 2 } }
    		@param depth {Number}		16
    		@param overwrite {Boolean}	Whether the deepest property in any of obj2 properties will overwrite obj1's
    		@return obj1				{ a: { c: 1, d: 2 } }
     */

    Transposer.prototype.merge = function(obj1, obj2, depth, overwrite) {
      var key, val1, val1Iterable, val1Type, val2, val2Iterable, val2Type;
      if (depth == null) {
        depth = 16;
      }
      if (overwrite == null) {
        overwrite = false;
      }
      if (depth > 0) {
        for (key in obj2) {
          if (!hasProp.call(obj2, key)) continue;
          val1 = obj1[key];
          val2 = obj2[key];
          val1Type = typeOf(val1);
          val2Type = typeOf(val2);
          val1Iterable = val1Type === 'object' || val1Type === 'array';
          val2Iterable = val2Type === 'object' || val2Type === 'array';
          if (key in obj1) {
            if (val1Iterable && val2Iterable) {
              if (overwrite && (val1Type !== val2Type || (val2Type === 'array' && !val2.length) || (val2Type === 'object' && !Object.keys(val2).length > 0))) {
                obj1[key] = val2;
              } else {
                this.merge(val1, val2, depth - 1, overwrite);
              }
            } else if (overwrite) {
              obj1[key] = val2;
            }
          } else {
            obj1[key] = val2;
          }
        }
      }
      return obj1;
    };

    return Transposer;

  })();

}).call(this);
